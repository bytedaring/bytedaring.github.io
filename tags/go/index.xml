<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Go on My New Hugo Site </title>
    <link>https://bytedaring.github.io/tags/go/index.xml</link>
    <language>en-us</language>
    <author>Alexander Ivanov</author>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>
    
    <item>
      <title>[转] Go Slice 秘籍</title>
      <link>https://bytedaring.github.io/post/go-slice/</link>
      <pubDate>Fri, 31 Mar 2017 13:42:17 CST</pubDate>
      <author>Alexander Ivanov</author>
      <guid>https://bytedaring.github.io/post/go-slice/</guid>
      <description>

&lt;p&gt;Golang官方总结： &lt;a href=&#34;https://github.com/golang/go/wiki/SliceTricks&#34;&gt;Slice Tricks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于引入了内建的&lt;code&gt;append&lt;/code&gt;的方法， 包&lt;code&gt;container/vector&lt;/code&gt;的很多方法都被移除，可以被内建的&lt;code&gt;append&lt;/code&gt;和&lt;code&gt;copy&lt;/code&gt;方法代替。&lt;/p&gt;

&lt;p&gt;下面是栈vector的操作方法的实现，使用slice实现相关的操作。&lt;/p&gt;

&lt;h2 id=&#34;1-append-vector&#34;&gt;1.  Append Vector&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, b...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-copy&#34;&gt;2.  Copy&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b = make([]T, len(a))
copy(b, a)
//如果a不为空， 等效实现
b = append([]T(nil), a...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-cut&#34;&gt;3.  Cut&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], a[j:]...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-delete&#34;&gt;4. Delete&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], a[i + 1]...)
// 或者
a = a[:i + copy(a[i:], a[i + 1])]	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-delete-而不保持原有顺序&#34;&gt;5. Delete,而不保持原有顺序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a[i] = a[len(a) - 1]
a = a[:len(a) - 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果需要被GC回收的元素是一个指针，或者struct含有指针字段，上面的cut，delete实现可能就导致内存泄漏：一些元素的值会被a一直引用而不会被回收。下面的实现可以解决这个问题:&lt;/p&gt;

&lt;h4 id=&#34;cut&#34;&gt;Cut&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;copy(a[i:], a[j:])
for k,n := len(a)-j+i, len(a); k&amp;lt;n; k++ {
  a[k] = nil
}
a = a[:len(a)-j+i]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delete&#34;&gt;Delete&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;copy(a[i:], a[i+1:])
a[len(a)-1] = nil
a = a[:len(a)-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delete-而不保持原来的顺序&#34;&gt;Delete 而不保持原来的顺序&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a[i] =a[len(a)-1]
a[len(a)-1]=nil
a = a[:len(a)-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-expand&#34;&gt;6.Expand&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], append(make([]T, j), a[i:]...)...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-extend&#34;&gt;7.Extend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, make([]T, j)...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-insert&#34;&gt;8.Insert&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], append([]T{x}, a[i:]...)...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ： 第二个append使用自己的底层存储创建一个新的slice，然后复制a[:i]中的元素到这个slice中，然后再把这些元素复制回a。新slice的创建和第二次的复制通过另外一种方式避免：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s = append(s, 0)
copy(s[i+1:], s[i:])
s[i] = x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-insert-vector&#34;&gt;9. Insert Vector&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], append(b, a[i:]...)...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-pop&#34;&gt;10. Pop&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, a  = a[len(a)-1], a[:len(a)-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11-push&#34;&gt;11.  Push&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-shift&#34;&gt;12. Shift&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, a := a[0], a[1:]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;13-unshift&#34;&gt;13. Unshift&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append([]T{x}, a...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14-其他技巧&#34;&gt;14.其他技巧&lt;/h3&gt;

&lt;h4 id=&#34;无新内存分配的过滤&#34;&gt;无新内存分配的过滤&lt;/h4&gt;

&lt;p&gt;这个技巧利用是： slice共享底层的array和存储容量。所以，在过滤slice时，会重用底层的存储。与此同时，底层存储的数据必然会被修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := a[:0]
for _, x := range a {
  if f(x) {
    b = append(b, x)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;反转&#34;&gt;反转&lt;/h4&gt;

&lt;p&gt;使用相同的元素（不分配新的对象）替换slice中内容，并将其反序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i:= len(a)/2 - 1; i &amp;gt;= 0; i--{
    opp := len(a)-1-i
    a[i], a[opp] = a[opp], a[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码实现同样的效果，只不过使用了两个索引变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for left, right := 0, len(a)-1; left &amp;lt; right; left, right = left + 1, right -1 {
    a[left] , r[right] = a[right], a[left]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
